A - Evitando quebrar os clientes: nova propriedade no modelo
Modelo de representação saída: tem retrocompatibilidade
Modelo de representação entrada: manter opcional por um tempo para manter retrocompatibilidade

B - Evitando quebrar os clientes: exclusão de propriedade do modelo
Modelo de representação saída: quebra de retrocompatibilidade, manter por um tempo com valor zero ou vazio por exemplo
Modelo de representação entrada: retirar da documentação e manter oculta sem validação por um tempo

C - Evitando quebrar os clientes: alteração de tipo de propriedade do modelo
Modelo de representação saída tipo amplo para específico: tem retrocompatibilidade
Modelo de representação saída tipo específico para amplo: adicionar uma nova propriedade e manter a antiga por um tempo
	informando na documentação como depreciada
Modelo de representação entrada tipo amplo para específico: pode ter quebra de retrocompatibilidade
Modelo de representação saída tipo específico para amplo: tem retrocompatibilidade

D - Evitando quebrar os clientes: alteração na estrutura de dados do modelo
Modelo de representação saída: mantenha retornando opções novas e antigas por um tempo depreciando a antiga
Modelo de representação entrada: aceite os modelos novos e antigos depreciando por um tempo a antiga e obrigando um ou
	outro se for o caso
	
E - Evitando quebrar os clientes: alteração de URL de recurso
Quebra a retrocompatibilidade, solução: manter url antiga e nova por um tempo,
	se usar Hateoas mantém a retrocompatibilidade e pode adicionar um novo link com rel novo para a mesma url
	


